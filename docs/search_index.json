[
["index.html", "Intro to R Workshop Book Chapter 1 Overview and Introduction 1.1 Datatypes 1.2 Functions", " Intro to R Workshop Book Shaun Jackson, Marissa Chemotti 2019-07-15 Chapter 1 Overview and Introduction The aim of this workshop is to get you up and running with R as quick as possible by teaching you how to connect the most important R constructs through hands-on examples. One of the toughest parts about learning a programming language is feeling overwhelmed by the abundance of material to learn. By giving you an overview of the most useful functions, in the lens of close-to-real-world artificial datasets, we hope that you can apply these concepts to your own data. As with everything else, the best way to learn R is through consistent practice with a real world project. 1.1 Datatypes R is a statistical software that allows user to provide a multitude of data tasks. In order to manipulate data, one would need to understand the fundamental R datatypes. 1.1.1 Numeric, Character, Logical, Factor 1.1.1.1 Numeric A numeric is self-explanatory. It could be a number that is either an integer, or a decimal In R we can assign a numeric to a number with the assignment operator &lt;-, or with an = sign. a &lt;- 1 1.1.1.2 Character A character is a representation of letters and or numbers and symbols. You would wrap the letters and numbers in either &quot;&quot; or '' marks to store as a character Assign a character value to a variable named a a &lt;- 'abc' 1.1.1.3 Logical A logical value also called a boolean value can only be TRUE or FALSE. These are powerful and allows the user to filter their data based on certain conditions. Assign a flag to TRUE flag &lt;- TRUE 1.1.1.3.1 Boolean operators Boolean operators are &lt; (less than) &gt; (greater than) == (equal to) notice two equal signs ! NOT operator: Turns a TRUE to FALSE or a FALSE to TRUE &amp; AND operator: Returns TRUE if all values TRUE, else FALSE | OR operator: Returns FALSE if all values FALSE, else TRUE A boolean operator returns a logical value or vector (will be explained) or matrix (will be explained) # quick example of boolean operators boolVal &lt;- 1 &lt; 5 boolVal ## [1] TRUE boolVal &lt;- 5 == 5 boolVal ## [1] TRUE boolVal &lt;- !(5 == 5) boolVal ## [1] FALSE 1.1.2 Vectors, Factors, Lists 1.1.2.1 Vectors A vector is a combination of values that have the same datatype. We use a function called c() to combine the values into a vector We put various values within the () separated by a comma vector1 &lt;- c(1, 2, 3) vector1 ## [1] 1 2 3 vector2 &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) vector2 ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; vector3 &lt;- c(TRUE, FALSE, TRUE) vector3 ## [1] TRUE FALSE TRUE Vectors are the fundamental datatypes that can make up a list, or a dataframe, which is how R represents a piece of data by rows and columns. We can names vectors by using the names() names(vector1) &lt;- c(&#39;a&#39;,&#39;b&#39;, &#39;c&#39;) vector1 ## a b c ## 1 2 3 1.1.2.2 Factor A factor is a special datatype that summarizes your data into a set of levels, where each level is a unique value of your data. It can be used to create Statistical Models we can create factors with the function: as.factor() factor1 &lt;- as.factor(c(&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;)) factor1 ## [1] a b b c ## Levels: a b c 1.1.2.3 Lists A list is similar to a vector in that it could hold multiple values. However, it is much more flexible. The difference is that it can hold multiple values of different datatypes. we can create lists with the function: list() it can also have names for each element in the list by doing: list(nameOfElement = valuesOfElement) list1 &lt;- list(a = 1, b = c(TRUE, FALSE), c = &#39;hi&#39;) list1 ## $a ## [1] 1 ## ## $b ## [1] TRUE FALSE ## ## $c ## [1] &quot;hi&quot; 1.1.3 Dataframes Dataframes are useful in that it organizes your data into rows and columns, similar to how data would be represented in a database, and excel sheet, or a simple CSV or TSV file. Every column has the same length could be thought of as a vector with one datatype. It holds additional attributes covered in the next section we can create dataframes with data.frame() dataframe1 &lt;- data.frame( col1 = c(1, 2, 3), col2 = c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) ) dataframe1 ## col1 col2 ## 1 1 a ## 2 2 b ## 3 3 c 1.1.4 Viewing datatypes with class() Using the class() function, we could see what datatype a variable is class(list1) ## [1] &quot;list&quot; class(vector1) ## [1] &quot;numeric&quot; class(dataframe1) ## [1] &quot;data.frame&quot; 1.2 Functions A function is an entity that performs an operation on an input, and returns an ouput Notice how we use syntax that has nameOfFunction with a () after it These are functions that take an input within the () and return an output For example the c() takes in multiple elements of the same type, and returns a vector of values the list() takes an input of values, and returns a list, the data.frame() takes an input of vectors of same length, and returns a dataframe We can create functions by the following syntax: plusOneFunction &lt;- function(input1) { # This is the function body # do something result &lt;- input1 + 1 return(result) # output } The inputs of our function are within the () The body of the function is where we perform operations on the input Calling return() will specify what output we want from our function The &lt;- assigns the function to a variable we can later on use In this case, plusOneFunction now can be used later on to perform an operation a &lt;- 1 b &lt;- plusOneFunction(a) # a will represent input1 b # b is the result after the return() ## [1] 2 Now that we’ve covered fundamental R types, we can begin the fun stuff- starting with Data Exploration "],
["data-input-output-and-exploration.html", "Chapter 2 Data Input, Output, and Exploration 2.1 Goals 2.2 Reading in Data 2.3 Observing Dataframe attributes 2.4 Subsetting Data 2.5 Filtering a dataframe: Subsetting part 2 2.6 Functions to explore data or find unclean data 2.7 Assignment 1: adosm2 dataset", " Chapter 2 Data Input, Output, and Exploration 2.1 Goals By the end of this chapter, you will be able to: Read a CSV file into your R environment Explore different attributes of a dataframe column names row names more with attributes() Subset a dataframe by rows and columns Filter a dataframe by the values of a column Use two data exploration and cleaning functions Frequency counts of unique values with table() Search for any duplicates within your data with duplicated() Write from your R environment to a CSV file 2.2 Reading in Data 2.2.1 Read CSV Files store the filepath within a character variable the filepath could be relative to your working directory, or absolute read.csv is a function that could read CSV files on your computer, and returns a dataframe for your R environment to use # define relative filepath pathToAdosFile &lt;- &#39;./datasets/adosm1.csv&#39; # Use read.csv() and filepath variable as first argument to function adosm1 &lt;- read.csv(pathToAdosFile, stringsAsFactors = FALSE) # stringsAsFactors is an optional argument that tells read.csv to # not turn a string column into a R factor variable # adosm1 is now considered a datraframe 2.3 Observing Dataframe attributes 2.3.1 View To view your dataframe call the View() function. Note the capital View(). View(adosm1) # After Viewing, you can click on columns to sort 2.3.2 See Attributes display column names names() display rownames with row.names() see all attributes with attributes(dataframe) # display column names # names(dataframe), we will use our adosm1 dataframe # wrap function with head() to show first 6 head(names(adosm1)) ## [1] &quot;id&quot; &quot;visit&quot; &quot;cbe_36&quot; ## [4] &quot;recruitment_group&quot; &quot;gender&quot; &quot;ados_version&quot; # display rownames, wrap function with head() to show first 6 head(row.names(adosm1)) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; 2.4 Subsetting Data In our case, adosm1 is within our R environment, so we would call adosm1[namesOfRows, namesOfColumns] 2.4.1 Subset by columns Note: it is best practice to subset columns by their names, not their numbers This is because subsetting by column names is more specific and less error-prone For ex. this can cause a problem if the columns were reordered # To access the id column, we would write adosm1[, &quot;id&quot;] # left of comma is empty to signify all rows to be accessed View(adosm1[, &quot;id&quot;]) # To access all rows, for columns id and visit adosm1[, c(&quot;id&quot;, &quot;visit&quot;)] # in order to make code less verbose, when accessing one column, # we use the $ operator # to access the id column adosm1$id Summary for accessing columns: For multiple columns adosm1[, c(&quot;nameOfColumn1&quot; &quot;nameOfColumn2&quot;)] For one column adosm1$nameOfColumn 2.4.2 Subset by rows We could similarly access rows by row numbers adosm1[c(1, 2, 5), ] We could also access rows by their row names adosm1[c(&quot;1&quot;, &quot;2&quot;, &quot;5&quot;)] Lastly, we could access rows with a logical vector (explained later) # access 1st, 2nd, and 5th rows # right of comma is empty to signify all columns to be accessed adosm1[c(1, 2, 5), ] 2.4.3 Subset by rows and columns # access 1st, 2nd, and 5th rows, within id and visit columns adosm1[c(1, 2, 5), c(&quot;id&quot;, &quot;visit&quot;)] 2.5 Filtering a dataframe: Subsetting part 2 2.5.1 Subset with a logical vector What is very powerful in this is we could subset a dataframe in order to answer specific questions This is done by using a logical vector to subset or slice a dataframe 2.5.2 Subset logical vector example # To Filter for all visits at 36 months: # Create logical vector visits36mo &lt;- adosm1$visit == &quot;36&quot; # This will return a vector that has a length equal to the # number of rows in our dataframe head(visits36mo) # TRUE are values = 36, FALSE not = 36 # use our visits36mo logical vector to filter dataframe adosm1[visits36mo, ] # returns a dataframe of all visits at 36mo adosm1[visits36mo, &quot;id&quot;] # returns all the ids with a visit at 36mo # returns alg and version at 36 months adosm1[visits36mo, c(&quot;ados_algorithm&quot;, &quot;ados_version&quot;)] 2.6 Functions to explore data or find unclean data 2.6.1 table() # To get a frequency count of all unique values, # we use the table() # table() takes in 1 or more vectors as input # since every dataframe column could be considered a vector (or list) # we could check for every unique visit with freq counts with table(adosm1$ados_version) ## ## ADOS-1 ADOS-2 ## 986 43 # we could check for every unique combination of vectors by # providing multiple vector inputs # To see every unique combination of visit and ados algorithm table(adosm1$visit, adosm1$ados_algorithm) ## ## few to no words no words some words ## 18 2 158 90 212 ## 21 0 0 7 2 ## 24 3 52 32 292 ## 30 0 6 0 32 ## 36 5 4 15 117 2.6.2 Checking for duplicates: duplicated() We will first generate a dataframe that has duplicates, to show how to detect duplicates by different subgroups dupDf &lt;- data.frame(id = c(1, 1, 2, 2, 3, 3), visit = c(&#39;10 months&#39;, &#39;20 months&#39;, &#39;10 months&#39;, &#39;10 months&#39;, &#39;20 months&#39;, &#39;20 months&#39;), item1 = c(1, 2, 3, 3, 5, 6)) The duplicated function returns a logical vector of the duplicates that exist in a dataframe The TRUE values represent the index locations of where a duplicate row was found We could use this logical vector to see where a duplicate exists duplicateIndices &lt;- duplicated(dupDf) # store dup vector in variable duplicateIndices # view logical vector of duplicates ## [1] FALSE FALSE FALSE TRUE FALSE FALSE dupDf[duplicateIndices, ] ## id visit item1 ## 4 2 10 months 3 2.6.3 Duplicated() by key variables: id and visit we could check for duplicates by columns that should represent a unique combination. in this example: id and visit # to check duplicates by groups dupIndGrouped &lt;- duplicated(dupDf[, c(&quot;id&quot;, &quot;visit&quot;)]) dupDf[dupIndGrouped, ] ## id visit item1 ## 4 2 10 months 3 ## 6 3 20 months 6 View(dupDf[dupIndGrouped, ]) # View duplicatecases by id and visit 2.7 Assignment 1: adosm2 dataset 2.7.1 Instructions Read in the adosm2.csv file What is the frequency count for every unique visit? What are the ids that exist for the 30 month visit? Are there duplicates by id and visit? What is the frequency count of duplicates vs non-duplicates? 2.7.2 Solution Assignment 1 # 1. Read in the adosm2.csv file adosm2Path &lt;- &#39;./datasets/adosm2.csv&#39; adosm2 &lt;- read.csv(adosm2Path, stringsAsFactors = FALSE) # 2. What is the frequency count for every unique visit? table(adosm2$visit) ## ## 24 30 36 School-Age ## 53 13 473 8 # 3, What are the ids that exist for the 30 month visit? adosm2[adosm2$visit == &quot;30&quot;, &quot;id&quot;] ## [1] 2 45 62 111 119 132 139 258 261 272 305 486 497 # This works too- adosm2$id[adosm2$visit == &quot;30&quot;] # 4. Are there duplicates by id and visit? table(duplicated(adosm2[, c(&quot;id&quot;, &quot;visit&quot;)])) ## ## FALSE ## 547 # 5. What are the frequency count of duplicates vs non-duplicates table(duplicated(adosm2)) ## ## FALSE ## 547 # There are no duplicates, so no need to filter out duplicates "],
["data-manipulation.html", "Chapter 3 Data Manipulation 3.1 Goals 3.2 Removing Duplicates 3.3 Cleaning, Scoring Messy Data 3.4 Merging datasets together 3.5 Score ADOS Module 1- Assignment 2 3.6 Writing Data", " Chapter 3 Data Manipulation 3.1 Goals By the end of this chapter, you will be able to: Gain Data Cleaning skills Remove duplicate data Clean data by replacing messy data with consistent data using ifelse() Gain data Manipulation skills Learn how to efficiently manipulate data with lapply() Score data with rowSums() and rowMeans() and lapply() Combine datasets together using merge() using rbind() and rbind.fill() Combining Sections 1 and 2 to Score the ADOS Module 1 Write your resulting dataframe with write.csv() 3.2 Removing Duplicates # Create duplicated dataframe dupDf &lt;- data.frame(id = c(1, 1, 2, 2, 3, 3), visit = c(&#39;10 months&#39;, &#39;20 months&#39;, &#39;10 months&#39;, &#39;10 months&#39;, &#39;20 months&#39;, &#39;20 months&#39;), item1 = c(1, 2, 3, 3, 5, 6)) # save logical vector of duplicate indices dupIndGrouped &lt;- duplicated(dupDf[, c(&quot;id&quot;, &quot;visit&quot;)]) dupIndGrouped ## [1] FALSE FALSE FALSE TRUE FALSE TRUE Before removing duplicates, it’s important to understand why there would be duplicates, and try to fix that issue Otherwise, here is another way to quickly remove them To remove duplicates, we use the same logical vector that found the duplicates We then inverse the vector by adding a (not sign) ! to toggle TRUES to FALSES and FALSES to TRUES By subsetting in this way, we will make a cleaner dataframe excluding all duplicate rows notDuplicateCases &lt;- !dupIndGrouped fixedDf &lt;- dupDf[notDuplicateCases, ] View(fixedDf) # View fixed dataframe 3.3 Cleaning, Scoring Messy Data 3.3.1 Messy Dataset We will create a dataset that is ‘unclean’ in order to teach you how to clean it messyDf &lt;- data.frame( id = c(1, 1, 2, 2, 3, 3), visit = c(&#39;10 months&#39;, &#39;20 months&#39;, &#39;10 months&#39;, &#39;20 months&#39;, &#39;10 months&#39;, &#39;20 months&#39;), item1 = c(1, 2, 3, 3, 5, 6), # item2 is a column with NAs item2 = c(NA, NA, 3, 4, 5, 6), # item3 is a column with multiple missing codes and NAs item3 = c(NA, &#39;Missing&#39;, &#39;-999&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;), # item 4 is a character column with different codes for same value item4Text = c(&#39;father&#39;, &#39;Father&#39;, &#39;fth&#39;, &#39;mother&#39;, &#39;Mother&#39;, &#39;Mother&#39;), # item 5 is a coded variable with text embedded within item5Codes = c(&#39;0 (Never)&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5 (Always)&#39;), item6 = c(1, 2, NA, NA, NA, NA), item7 = c(1, 2, 3, NA, NA, 6) ) 3.3.2 Replacing values with ifelse() ifelse() is a vectorized function that uses matrix-like operations for increased efficiency It can take in a vector of values, and return a vector of values of the same length Function Signature: ifelse(condition, value if condition true, value if condition false) The condition is a logical vector which could be created with boolean operators (eg. ==, &lt;, &gt;) or any function that returns a logical operator: eg. duplicated(), grepl(), is.na(). The second parameter is what value will be returned for all TRUEs in the preceding logical vector The third parameter is what value will be returned for all FALSEs in the 1st condition logical vector 3.3.3 Replacing NAs with ifelse() For example, we can replace all NAs with 0 by also using the is.na(). is.na() takes in a vector of values This function will take the input vector, and return a logical vector, same as what duplicated() did, where TRUEs are where an NA was found, and FALSE otherwise. is.na(messyDf$item2) ## [1] TRUE TRUE FALSE FALSE FALSE FALSE # for all NAs replace with 0, otherwise replace with original value ifelse(is.na(messyDf$item2), 0, messyDf$item2) ## [1] 0 0 3 4 5 6 # We use this vector and assign it to the original column to clean it messyDf$item2 &lt;- ifelse(is.na(messyDf$item2), 0, messyDf$item2) 3.3.4 Nesting ifelse() to replace multiple values To fix item3, we need to have a consistent code for Missing Notice how NA, Missing, and -999, all represent Missing To replace all 3 cases, we can do so by nesting ifelse statements. To do this, we nest ifelse statements: ifelse(condition1, value1, ifelse(condition2, value2, value3)) This example replaces all TRUE values from condition1 with value 1 It then replaces all TRUE values from condition2 with value2, Lastly, all the remaining FALSE values are replaced with value3 3.3.4.1 Replacing multiple values: NAs, -999s, Missing codes # See logical vector of NAs is.na(messyDf$item3) ## [1] TRUE FALSE FALSE FALSE FALSE FALSE # See logical vector of -999s messyDf$item3 == &#39;-999&#39; ## [1] NA FALSE TRUE FALSE FALSE FALSE # See logical vector of &#39;Missing&#39; messyDf$item3 == &#39;Missing&#39; ## [1] NA TRUE FALSE FALSE FALSE FALSE # for all NAs replace with 0, otherwise replace with original value ifelse(is.na(messyDf$item3), &#39;-9&#39;, ifelse(messyDf$item3 == &#39;-999&#39;, &#39;-9&#39;, ifelse(messyDf$item3 == &#39;Missing&#39;, &#39;-9&#39;, messyDf$item3))) ## [1] &quot;-9&quot; &quot;-9&quot; &quot;-9&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; # We use this vector and assign it to the original column to clean it messyDf$item3 &lt;- ifelse(is.na(messyDf$item3), &#39;-9&#39;, ifelse(messyDf$item3 == &#39;-999&#39;, &#39;-9&#39;, ifelse(messyDf$item3 == &#39;Missing&#39;, &#39;-9&#39;, messyDf$item3))) 3.3.4.2 Replacing multiple values with the %in% we can condense the previous ifelse statements with %in% ifelse(is.na(messyDf$item3), &#39;-9&#39;, ifelse(messyDf$item3 %in% c(&#39;-999&#39;, &#39;Missing&#39;), &#39;-9&#39;, messyDf$item3)) 3.3.5 lapply(): Applying a function over multiple columns with 3.3.5.1 lapply() stands for list apply think of a column in a dataframe as a list. we apply a function to multiple lists with lapply() so we could apply a function to multiple columns with lapply() Function Signature: lapply(dataframe[, c(colsToApplyFunction)], functionToApply) The first parameter is a dataframe subsetted by the columns we want to manipulate The second parameter is the function we want to apply to each column It returns all the columns within the first parameter, but the result of what functionToApply did If we want to replace all NAs with 0 for items 2, 6, and 7: messyDf[, c(&#39;item2&#39; , &#39;item6&#39;, &#39;item7&#39;)] ## item2 item6 item7 ## 1 0 1 1 ## 2 0 2 2 ## 3 3 NA 3 ## 4 4 NA NA ## 5 5 NA NA ## 6 6 NA 6 replaceNAsWithZero &lt;- function(x) { x &lt;- ifelse(is.na(x), 0, x) return(x) } lapply(messyDf[, c(&#39;item2&#39; , &#39;item6&#39;, &#39;item7&#39;)], replaceNAsWithZero) ## $item2 ## [1] 0 0 3 4 5 6 ## ## $item6 ## [1] 1 2 0 0 0 0 ## ## $item7 ## [1] 1 2 3 0 0 6 # We can also just put the function within the second parameter like this: lapply(messyDf[, c(&#39;item2&#39; , &#39;item6&#39;, &#39;item7&#39;)], function(x) { x &lt;- ifelse(is.na(x), 0, x) return(x) }) ## $item2 ## [1] 0 0 3 4 5 6 ## ## $item6 ## [1] 1 2 0 0 0 0 ## ## $item7 ## [1] 1 2 3 0 0 6 # We assign the result to the original columns to apply function to these cols messyDf[, c(&#39;item2&#39; , &#39;item6&#39;, &#39;item7&#39;)] &lt;- lapply(messyDf[, c(&#39;item2&#39; , &#39;item6&#39;, &#39;item7&#39;)], function(x) { x &lt;- ifelse(is.na(x), 0, x) return(x) }) messyDf[, c(&#39;item2&#39; , &#39;item6&#39;, &#39;item7&#39;)] ## item2 item6 item7 ## 1 0 1 1 ## 2 0 2 2 ## 3 3 0 3 ## 4 4 0 0 ## 5 5 0 0 ## 6 6 0 6 3.3.6 Scoring Data with rowSums() and rowMeans() Say we have a scoring algorithm where the sum of items 2, 6, and 7 represent one scale And means of items 2, 6, and 7 represent another scale Also say we want to count all the zeros, where a zero represents missing. If more than 1 zero, the scales will be invalid rowSums() takes in a subsetted dataframe, and returns the sum of all those values rowMeans() takes in a subsetted dataframe, and returns the mean of all those values total_sum &lt;- rowSums(messyDf[, c(&#39;item2&#39;, &#39;item6&#39;, &#39;item7&#39;)]) total_sum ## [1] 2 4 6 4 5 12 # if there are NAs, we do # rowSums(messyDf[, c(&#39;item2&#39;, &#39;item6&#39;, &#39;item7&#39;)], na.rm=TRUE) total_mean &lt;- rowMeans(messyDf[, c(&#39;item2&#39;, &#39;item6&#39; ,&#39;item7&#39;)]) total_mean ## [1] 0.6666667 1.3333333 2.0000000 1.3333333 1.6666667 4.0000000 # to count all 0s, we sum the amount of TRUE values in a logical vector messyDf[, c(&#39;item2&#39;, &#39;item6&#39;, &#39;item7&#39;)] == 0 ## item2 item6 item7 ## [1,] TRUE FALSE FALSE ## [2,] TRUE FALSE FALSE ## [3,] FALSE TRUE FALSE ## [4,] FALSE TRUE TRUE ## [5,] FALSE TRUE TRUE ## [6,] FALSE TRUE FALSE total_missings &lt;- rowSums(messyDf[, c(&#39;item2&#39;, &#39;item6&#39;, &#39;item7&#39;)] == 0) total_missings ## [1] 1 1 1 2 2 1 # store these values in columns messyDf$total_sum &lt;- total_sum messyDf$total_mean &lt;- total_mean messyDf$total_missings &lt;- total_missings # if more than 1 zero, data invalid messyDf$invalid_flag &lt;- messyDf$total_missings &gt; 1 messyDf[, c(&#39;total_sum&#39;, &#39;total_mean&#39;, &#39;total_missings&#39;, &#39;invalid_flag&#39;)] ## total_sum total_mean total_missings invalid_flag ## 1 2 0.6666667 1 FALSE ## 2 4 1.3333333 1 FALSE ## 3 6 2.0000000 1 FALSE ## 4 4 1.3333333 2 TRUE ## 5 5 1.6666667 2 TRUE ## 6 12 4.0000000 1 FALSE 3.4 Merging datasets together One important skill when working with R is merging data from multiple files into one dataframe There are multiple ways to do this, such as using sqldf() or merge(). To stick with base R, we will use merge() 3.4.1 Creating datasets to merge subjects &lt;- data.frame( id = c(1, 2, 3), clincalBestEst = c(&#39;ASD&#39;, &#39;Non-ASD&#39;, &#39;Non-ASD&#39;) ) visits &lt;- data.frame( id = c(1, 1, 2, 2, 3, 3), visit = c(&#39;18mo&#39;, &#39;36mo&#39;, &#39;18mo&#39;, &#39;36mo&#39;, &#39;18mo&#39;, &#39;36mo&#39;), date_of_testing = c(&#39;2017-02-03&#39;, &#39;2018-08-03&#39;, &#39;2017-02-04&#39;, &#39;2018-08-04&#39;, &#39;2018-01-04&#39;, &#39;2019-07-03&#39;) ) ados_scores &lt;- data.frame( id = c(1, 2, 3), visit = c(&#39;36mo&#39;, &#39;36mo&#39;, &#39;36mo&#39;), ados_sarb_total = c(10, 1, 2) ) # if reading from different files, just replace &lt;- data.frame() # with read.csv(filepath, stringsAsFactors=FALSE) 3.4.2 Merging with merge() To merge a dataset, we first need to know the columns we will merge by In this case, we can merge the subjects and visits dataframes by id We can merge the result of the previous merge, with id and visit Using merge(), it takes in two dataframes, and a by parameter as well as a all.x or all,.y or all parameter # all.x creates a LEFT JOIN master &lt;- merge(subjects, visits, by = c(&#39;id&#39;), all.x = TRUE) master ## id clincalBestEst visit date_of_testing ## 1 1 ASD 18mo 2017-02-03 ## 2 1 ASD 36mo 2018-08-03 ## 3 2 Non-ASD 18mo 2017-02-04 ## 4 2 Non-ASD 36mo 2018-08-04 ## 5 3 Non-ASD 18mo 2018-01-04 ## 6 3 Non-ASD 36mo 2019-07-03 master &lt;- merge(master, ados_scores, by = c(&#39;id&#39;, &#39;visit&#39;), all.x = TRUE) master ## id visit clincalBestEst date_of_testing ados_sarb_total ## 1 1 18mo ASD 2017-02-03 NA ## 2 1 36mo ASD 2018-08-03 10 ## 3 2 18mo Non-ASD 2017-02-04 NA ## 4 2 36mo Non-ASD 2018-08-04 1 ## 5 3 18mo Non-ASD 2018-01-04 NA ## 6 3 36mo Non-ASD 2019-07-03 2 # if the first and second parameters have difference colnames that represent # the same value, we can use by.x = , or by.y =, 3.4.3 Stacking dataframes with rbind 3.4.3.1 Read in data to stack or row bind together adosm1 &lt;- read.csv(&#39;./datasets/adosm1.csv&#39;, stringsAsFactors = FALSE) adosm2 &lt;- read.csv(&#39;./datasets/adosm2.csv&#39;, stringsAsFactors = FALSE) ados &lt;- rbind(adosm1, adosm2) # if datasets have columns that are not the same, use rbind.fill within plyr package 3.4.4 data.table::fwrite() One you are comfortable with write.csv, I would suggest looking into the fwrite function within data.table. It is much much faster and more efficient. 3.5 Score ADOS Module 1- Assignment 2 3.5.1 Instructions Read in the adosm1.csv file If item b1, replace NAs or Missings with 0, replace value 1 or 3, with 2, replace items 0 or 2, with 0, otherwise keep original value For all other items, replace NAs or Missing codes with 0, replace value 3, with 2, keep values between 0, 1, 2 the same as itself, replace all others with 0 Score SA total If ados_algorithm is ‘no words’, or ‘few to no words’, the sa_total = rowSums of ados_a2, ados_a8, ados_b1, ados_b3, ados_b4, ados_b5, ados_b9, ados_b10, ados_b11 If ados_aglorithm is some words, the sa_total = rowSums of ados_a2, ados_a7, ados_a8, ados_b1, ados_b3, ados_b4, ados_b5, ados_b9, ados_b10 Score RRB total If ados_algorithm is ‘no words’, or ‘few to no words’, the rrb_total = rowSums of ados_a3, ados_d1, ados_d2, ados_d4 If ados_aglorithm is some words, the rrb_total = rowSums of ados_a5, ados_d1, ados_d2, ados_d4 Score SARB total SARB total = sa_total + rrb_total 3.5.2 Solution 3.5.2.1 Solution Part 1 # 1. Read in adosm1.csv adosm1 &lt;- read.csv(&#39;./datasets/adosm1.csv&#39;, stringsAsFactors = FALSE) # store backup to restore original vals adosm1_backup &lt;- adosm1 3.5.2.2 Solution Part 2 # 2. If item b1, # - replace NAs or Missings with 0, # - replace value 1 or 3, with 2, # - replace items 0 or 2, with 0, # create function to apply to item b1 and replace values properly item_b1_replace &lt;- function(item) { # items may be characters because of missings codes, so first replace with # chars, then turn to numerics item &lt;- as.character(item) newVal &lt;- ifelse(is.na(item), &#39;0&#39;, # replace NAs with 0 ifelse(item %in% c(&#39;-999&#39;, &#39;9&#39;, &#39;Missing (-9)&#39;),&#39; 0&#39;, # replace missings with 0 ifelse(item %in% c(&#39;1&#39;, &#39;3&#39;), &#39;2&#39;, # replace 1 or 3 with 2 ifelse(item %in% c(&#39;0&#39;, &#39;2&#39;), &#39;0&#39;, item)))) # replace 0 or 2 with 0, else item newVal &lt;- as.numeric(newVal) return(newVal) } adosm1$ados_b1 &lt;- item_b1_replace(adosm1$ados_b1) 3.5.2.3 Solution Part 3 # 3. For all other items, # - replace NAs or Missing codes with 0, # - replace value 3, with 2, # - keep values between 0, 1, 2 the same as itself, # - replace all others with 0. item_replace &lt;- function(item) { # items may be characters because of missings codes, so first replace with # chars, then turn to numerics item &lt;- as.character(item) newVal &lt;- ifelse(is.na(item), &#39;0&#39;, # replace NAs with 0 ifelse(item %in% c(&#39;-999&#39;, &#39;9&#39;, &#39;Missing (-9)&#39;, &#39;999&#39;), &#39;0&#39;, # replace missings with 0 ifelse(item == &#39;3&#39;, &#39;2&#39;, # replace 3 with 2 ifelse(item %in% c(&#39;0&#39;, &#39;1&#39;, &#39;2&#39;), item, &#39;0&#39;)))) newVal &lt;- as.numeric(newVal) return(newVal) } names(adosm1) ## [1] &quot;id&quot; &quot;visit&quot; &quot;cbe_36&quot; ## [4] &quot;recruitment_group&quot; &quot;gender&quot; &quot;ados_version&quot; ## [7] &quot;ados_algorithm&quot; &quot;ados_a1&quot; &quot;ados_a2&quot; ## [10] &quot;ados_a3&quot; &quot;ados_a4&quot; &quot;ados_a5&quot; ## [13] &quot;ados_a6&quot; &quot;ados_a7&quot; &quot;ados_a8&quot; ## [16] &quot;ados_b1&quot; &quot;ados_b2&quot; &quot;ados_b3&quot; ## [19] &quot;ados_b4&quot; &quot;ados_b5&quot; &quot;ados_b6&quot; ## [22] &quot;ados_b7&quot; &quot;ados_b8&quot; &quot;ados_b9&quot; ## [25] &quot;ados_b10&quot; &quot;ados_b11&quot; &quot;ados_b12&quot; ## [28] &quot;ados_b13a&quot; &quot;ados_b13b&quot; &quot;ados_b14&quot; ## [31] &quot;ados_b15&quot; &quot;ados_b16&quot; &quot;ados_c1&quot; ## [34] &quot;ados_c2&quot; &quot;ados_d1&quot; &quot;ados_d2&quot; ## [37] &quot;ados_d3&quot; &quot;ados_d4&quot; &quot;ados_e1&quot; ## [40] &quot;ados_e2&quot; &quot;ados_e3&quot; # use regular expressions to obtain columns b1, or all other scoring columns # we did not yet cover this, but here is an example. The alternative will # be to write each individual colname ados_all_items &lt;- grep(&#39;ados_[abcde][0123456789]&#39;, names(adosm1), value=TRUE) ados_all_not_b1 &lt;- setdiff(ados_all_items, &#39;ados_b1&#39;) # all items not ados_b1 adosm1[, ados_all_not_b1] &lt;- lapply(adosm1[, ados_all_not_b1], item_replace) 3.5.2.4 Solution Part 4 # 4. Score SA total # - If ados_algorithm is &#39;no words&#39;, or &#39;few to no words&#39;, the sa_total = # - rowSums of ados_a2, ados_a8, ados_b1, ados_b3, ados_b4, ados_b5, ados_b9, ados_b10, ados_b11 # - If ados_aglorithm is some words, the sa_total = # - rowSums of ados_a2, ados_a7, ados_a8, ados_b1, ados_b3, ados_b4, ados_b5, ados_b9, ados_b10 no_words_sa_items &lt;- c(&#39;ados_a2&#39;, &#39;ados_a8&#39;, &#39;ados_b1&#39;, &#39;ados_b3&#39;, &#39;ados_b4&#39;, &#39;ados_b5&#39;, &#39;ados_b9&#39;, &#39;ados_b10&#39;, &#39;ados_b11&#39;) no_words_sa &lt;- rowSums(adosm1[, no_words_sa_items]) # we can use regExpr to obtain items some_words_sa_items &lt;- grep(&#39;^ados_a[278]$|^ados_b[13459]$|^ados_b1[01]$&#39;, names(adosm1), value=TRUE) some_words_sa &lt;- rowSums(adosm1[ some_words_sa_items]) adosm1$ados_sa_total &lt;- ifelse(adosm1$ados_algorithm %in% c(&#39;no words&#39;, &#39;few to no words&#39;), no_words_sa, ifelse(adosm1$ados_algorithm %in% c(&#39;some words&#39;), some_words_sa, NA)) 3.5.2.5 Solution Part 5 # 5. Score RRB total # - If ados_algorithm is &#39;no words&#39;, or &#39;few to no words&#39;, the rrb_total = # - rowSums of ados_a3, ados_d1, ados_d2, ados_d4 # - If ados_aglorithm is some words, the rrb_total = # - rowSums of ados_a5, ados_d1, ados_d2, ados_d4, # ados_b3, ados_b4, ados_b5, ados_b9, ados_b10 no_words_rrb_items &lt;- c(&#39;ados_a3&#39;, &#39;ados_d1&#39;, &#39;ados_d2&#39;, &#39;ados_d4&#39;) no_words_rrb &lt;- rowSums(adosm1[, no_words_rrb_items]) # we can use regExpr to obtain items some_words_rrb_items &lt;- grep(&#39;^ados_a[5]$|^ados_d[124]$&#39;, names(adosm1), value=TRUE) some_words_rrb &lt;- rowSums(adosm1[ some_words_rrb_items]) adosm1$ados_rrb_total &lt;- ifelse(adosm1$ados_algorithm %in% c(&#39;no words&#39;, &#39;few to no words&#39;), no_words_rrb, ifelse(adosm1$ados_algorithm %in% c(&#39;some words&#39;), some_words_rrb, NA)) 3.5.2.6 Solution Part 6 # 6. Score SARB total # - SARB total = # - sa_total + rrb_total adosm1$ados_sarrb_total &lt;- adosm1$ados_sa_total + adosm1$ados_rrb_total # optional- replace all manipulated items back to original adosm1[, ados_all_items] &lt;- adosm1_backup[, ados_all_items] head(adosm1) ## id visit cbe_36 recruitment_group gender ados_version ados_algorithm ## 1 1 18 Non-TD High risk Male ADOS-1 some words ## 2 1 24 TD High risk Female ADOS-1 some words ## 3 2 18 TD Low risk Female ADOS-1 some words ## 4 2 24 TD High risk Female ADOS-1 some words ## 5 3 18 TD Low risk Male ADOS-1 few to no words ## 6 4 18 Non-TD High risk Male ADOS-1 few to no words ## ados_a1 ados_a2 ados_a3 ados_a4 ados_a5 ados_a6 ados_a7 ados_a8 ados_b1 ## 1 3 0 0 0 0 0 1 1 0 ## 2 2 0 0 0 1 0 0 0 0 ## 3 0 0 0 0 8 0 1 0 0 ## 4 0 0 0 0 0 0 1 0 0 ## 5 8 1 0 1 8 0 1 0 0 ## 6 8 0 0 8 8 0 1 1 0 ## ados_b2 ados_b3 ados_b4 ados_b5 ados_b6 ados_b7 ados_b8 ados_b9 ados_b10 ## 1 0 0 0 0 0 1 0 0 0 ## 2 0 0 0 0 1 0 1 0 0 ## 3 0 0 0 0 0 0 0 0 0 ## 4 1 0 0 1 0 1 0 0 0 ## 5 1 0 0 0 0 0 0 2 0 ## 6 0 0 1 0 1 0 2 1 0 ## ados_b11 ados_b12 ados_b13a ados_b13b ados_b14 ados_b15 ados_b16 ados_c1 ## 1 0 0 NA NA NA NA NA 0 ## 2 0 0 NA NA NA NA NA 0 ## 3 0 0 NA NA NA NA NA 1 ## 4 0 0 NA NA NA NA NA 0 ## 5 0 0 NA NA NA NA NA 0 ## 6 2 0 NA NA NA NA NA 2 ## ados_c2 ados_d1 ados_d2 ados_d3 ados_d4 ados_e1 ados_e2 ados_e3 ## 1 1 1 0 0 0 1 NA 1 ## 2 0 0 0 0 0 0 0 1 ## 3 0 0 0 0 0 1 0 999 ## 4 1 0 0 0 1 0 0 1 ## 5 1 0 0 0 0 0 0 0 ## 6 1 1 1 0 2 1 0 0 ## ados_sa_total ados_rrb_total ados_sarrb_total ## 1 2 1 3 ## 2 0 1 1 ## 3 1 0 1 ## 4 2 1 3 ## 5 3 0 3 ## 6 5 4 9 3.6 Writing Data 3.6.1 write.csv We can write data from our R environment to a CSV file with write.csv write.csv takes in a dataframe within our R environment, as the first parameter the second parameter is the location and filename to write it to. For example, after scoring our adosm1 dataset, we can now write it to a location # write.csv(adosm1, &#39;./datasets/ADOS Module 1 Scored&#39;, row.names = FALSE) Congratulations! We have now covered and combined all the essentials in working with data manipulation. In the next section, we will cover data visualization and analysis tools within R "],
["data-visualization-and-analysis.html", "Chapter 4 Data Visualization and Analysis 4.1 Read in Data 4.2 Data Visualization with ggplot 4.3 Basic Stats functions 4.4 Linear Regression 4.5 Logistic Regression 4.6 Mixed Effects Models 4.7 More Resources", " Chapter 4 Data Visualization and Analysis 4.1 Read in Data Our input data will be a scored version of the artificial ADOS Module 2dataset with some fake columns to demonstrate how to use R to perform specific data analyses. adosm2 &lt;- read.csv(&#39;./datasets/adosm2_scored.csv&#39;, stringsAsFactors = FALSE) 4.2 Data Visualization with ggplot 4.2.1 Plotting points library(ggplot2) ggplot(data = adosm2) + geom_point(mapping = aes(x = ados_fake_lin_outcome, y = ados_sarb_total, color = recruitment_group)) 4.2.2 Plotting with Points and Smooth ggplot(data = adosm2, mapping = aes(x = ados_sarb_total, y = ados_fake_lin_outcome)) + geom_point(mapping = aes(color = recruitment_group)) + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 4.2.3 Bar Plots 4.2.3.1 Bar plot with Colors ggplot(data = adosm2) + geom_bar(mapping = aes(x = recruitment_group, fill = gender)) 4.2.3.2 Bar plot with separated colors and positions ggplot(data = adosm2) + geom_bar(mapping = aes(x = recruitment_group, fill = gender), position = &quot;dodge&quot;) 4.2.4 Box Plots ggplot(data = adosm2, mapping = aes(x = recruitment_group, y = ados_sarb_total)) + geom_boxplot() 4.3 Basic Stats functions 4.3.1 Mean, Median, Standard Deviation, Summary mean(adosm2$ados_sarb_total, na.rm = TRUE) ## [1] 3.488117 median(adosm2$ados_sarb_total, na.rm = TRUE) ## [1] 3 sd(adosm2$ados_sarb_total, na.rm = TRUE) ## [1] 3.02392 summary(adosm2$ados_sarb_total) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.000 1.500 3.000 3.488 4.000 19.000 4.3.2 Chi Squared Test chisq.test(table(adosm2$cbe_36, adosm2$recruitment_group)) ## Warning in chisq.test(table(adosm2$cbe_36, adosm2$recruitment_group)): Chi- ## squared approximation may be incorrect ## ## Pearson&#39;s Chi-squared test ## ## data: table(adosm2$cbe_36, adosm2$recruitment_group) ## X-squared = 15.284, df = 4, p-value = 0.004147 4.4 Linear Regression 4.4.1 Correlation Find correlation between two vars cor.test(adosm2$ados_fake_score1, adosm2$ados_fake_lin_outcome) ## ## Pearson&#39;s product-moment correlation ## ## data: adosm2$ados_fake_score1 and adosm2$ados_fake_lin_outcome ## t = -22.232, df = 545, p-value &lt; 2.2e-16 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## -0.7311983 -0.6429767 ## sample estimates: ## cor ## -0.6896378 4.4.2 Creating a Linear Regression Model We use the lm() functionn to create a Linear Regression Model The first parameter takes in an equation of the form: dependentVar ~ predictor1 + predictor2 + ... So the dependentVar is a function of the predictor variables In order to use column names as variables in this eq., the data parameter takes in a dataframe as input. # To demonstrate a linear model, we use fake ados columns within the ados # dataframe linearMod &lt;- lm(ados_fake_lin_outcome ~ ados_fake_score1 + ados_fake_score2, data=adosm2) 4.4.3 Residuals, P-Values, Coefficients, with summary() summary(linearMod) ## ## Call: ## lm(formula = ados_fake_lin_outcome ~ ados_fake_score1 + ados_fake_score2, ## data = adosm2) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.75987 -0.68070 0.04043 0.65436 3.11995 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.01635 0.04233 0.386 0.7 ## ados_fake_score1 -3.04059 0.04225 -71.970 &lt;2e-16 *** ## ados_fake_score2 3.01164 0.04292 70.176 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9894 on 544 degrees of freedom ## Multiple R-squared: 0.9478, Adjusted R-squared: 0.9476 ## F-statistic: 4942 on 2 and 544 DF, p-value: &lt; 2.2e-16 4.4.4 Plotting the Linear Model # create effects object plot(effects::Effect(c(&#39;ados_fake_score1&#39;), linearMod)) plot(effects::Effect(c(&#39;ados_fake_score2&#39;), linearMod)) plot(effects::Effect(c(&#39;ados_fake_score1&#39;, &#39;ados_fake_score2&#39;), linearMod)) 4.5 Logistic Regression adosm2$cbe_asd &lt;- ifelse(adosm2$cbe_36 %in% c(&#39;Autism&#39;, &#39;ASD&#39;), &#39;ASD&#39;, &#39;Non-ASD&#39;) adosm2$cbe_asd &lt;- as.factor(adosm2$cbe_asd) adosm2$cbe_asd &lt;- relevel(adosm2$cbe_asd, ref = &#39;Non-ASD&#39;) mod &lt;- glm(cbe_asd ~ 1 + ados_sarb_total, data = adosm2, family = &#39;binomial&#39;) eff &lt;- effects::Effect(c(&#39;ados_sarb_total&#39;), mod) plot(eff, axes = list( y = list( lab = &#39;CBE of ASD&#39;, ticks = list(at = c(.01, .1, .2, .4, .6, .8, .99)))) ) 4.6 Mixed Effects Models 4.6.1 Mixed Effects Logistic Regression # analyze- logistic regression mixed effects adosm2$cbe_asd &lt;- ifelse(adosm2$cbe_36 %in% c(&#39;Autism&#39;, &#39;ASD&#39;), &#39;ASD&#39;, &#39;Non-ASD&#39;) adosm2$cbe_asd &lt;- as.factor(adosm2$cbe_asd) adosm2$cbe_asd &lt;- relevel(adosm2$cbe_asd, ref = &#39;Non-ASD&#39;) mod &lt;- lme4::glmer(cbe_asd ~ 1 + (1|visit) + ados_sarb_total, data = adosm2, family = &#39;binomial&#39;) eff &lt;- effects::Effect(c(&#39;ados_sarb_total&#39;), mod) plot(eff, axes = list( y = list( lab = &#39;CBE of ASD&#39;, ticks = list(at = c(.01, .1, .2, .4, .6, .8, .99)))) ) 4.7 More Resources "]
]
