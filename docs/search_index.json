[
["index.html", "Intro to R Workshop Book Chapter 1 Overview and Introduction", " Intro to R Workshop Book Shaun Jackson, Marissa Chemotti 7/3/2019 Chapter 1 Overview and Introduction The aim of this workshop is to get you up and running with R as quick as possible by teaching you how to connect the most important R constructs through hands-on examples. One of the toughest parts about learning a programming language is feeling overwhelmed by the abundance of material to learn. By giving you an overview of the most useful functions, in the lens of close-to-real-world artificial datasets, we hope that you can apply these concepts to your own data. As with everything else, the best way to learn R is through consistent practice with a real world project. "],
["part-1-introduction-and-data-exploration.html", "Chapter 2 Part 1: Introduction and Data Exploration 2.1 Goals 2.2 Datatypes", " Chapter 2 Part 1: Introduction and Data Exploration 2.1 Goals By the end of this document, you will be able to: Learn about the fundamental R Datatypes Read a CSV file into your R environment Write from your R environment to a CSV file Explore different attributes of a dataframe column names row names more with attributes() Subset a dataframe by rows and columns Filter a dataframe by the values of a column Use two data exploration and cleaning functions Frequency counts of unique values with table() Search for any duplicates within your data with duplicated() In this section, we introduce to you the Fundamental R Datatypes, Data input and data output, as well as some useful data exploration functions. 2.2 Datatypes 2.2.1 Numeric, Logical, Character, Factor 2.2.2 Lists, Vectors, Matrices 2.2.3 Dataframes "],
["reading-in-data.html", "Chapter 3 Reading in Data 3.1 Writing Data 3.2 Subsetting Data 3.3 Filtering a dataframe: Subsetting part 2 3.4 Functions to explore data 3.5 Assignment: adosm2 dataset 3.6 Additional Resources 3.7 Solution 3.8 Basic Stats functions 3.9 Linear Regression 3.10 Logistic Regression 3.11 Mixed Effects Models 3.12 Plotting with effects 3.13 Plotting with ggplot 3.14 More Resources 3.15 Bonus Material (Optional) 3.16 String Manipulation", " Chapter 3 Reading in Data 3.0.1 Read CSV Files store the filepath within a character variable the filepath could be relative to your working directory, or absolute read.csv is a function that could read CSV files into your R environment # define relative filepath pathToAdosFile &lt;- &#39;./datasets/adosm1.csv&#39; # Use read.csv() and filepath variable as first argument to function adosm1 &lt;- read.csv(pathToAdosFile, stringsAsFactors = FALSE) # stringsAsFactors is an optional argument that tells read.csv to # not turn a string column into a R factor variable # adosm1 is now considered a datraframe 3.0.2 View() To view your dataframe call the View() function. Note the capital View(). View(adosm1) 3.0.3 See Dataframe attributes display column names names() display rownames with row.names() see all attributes with attributes(dataframe) # display column names # names(dataframe), we will use our adosm1 dataframe # wrap function with head() to show first 5 head(names(adosm1)) ## [1] &quot;id&quot; &quot;visit&quot; &quot;cbe_36&quot; ## [4] &quot;recruitment_group&quot; &quot;gender&quot; &quot;ados_version&quot; # display rownames, wrap function with head() to show first 5 head(row.names(adosm1)) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; 3.1 Writing Data 3.1.1 write.csv We can write data from our R environment to a CSV file with write.csv write.csv takes in a dataframe within our R environment, as the first parameter the second parameter is the location and filename to write it to. # write.csv(adosm1, &#39;datasets/practice write csv ados.csv&#39;, row.names = FALSE) 3.1.2 data.table::fwrite() One you are comfortable with write.csv, I would suggest looking into the fwrite function within data.table. It is much much faster and more efficient. 3.2 Subsetting Data 3.2.1 Subset by columns In our case, adosm1 is within our R environment, so we would call adosm1[namesOfRows, namesOfColumns] Note: it is best practice to access columns by their names, not their numbers # To access the id column, we would write adosm1[, &quot;id&quot;] # To access id and visit adosm1[, c(&quot;id&quot;, &quot;visit&quot;)] # in order to make code less verbose, when accessing one column, we use # the $ operator # to access the id column adosm1$id 3.2.2 Subset by rows We could similarly access rows by rownames or row numbers adosm1[c(1, 2, 5), ] # access 1st, 2nd, and 5th rows adosm1[c(1, 2, 5), ] 3.2.3 Subset by rows and columns # access 1st, 2nd, and 5th rows, within id and visit columns adosm1[c(1, 2, 5), c(&quot;id&quot;, &quot;visit&quot;)] 3.3 Filtering a dataframe: Subsetting part 2 3.3.1 Subset with a logical vector What is very powerful in this is we could subset a dataframe in order to answer specific questions This is done by using a logical vector to subset or slice a dataframe 3.3.2 Subset logical vector example # To Filter for all visits at 36 months: # Create logical vector visits36mo &lt;- adosm1$visit == &quot;36&quot; # use our visits36mo logical vector to filter dataframe adosm1[visits36mo, ] # returns a dataframe of all visits at 36mo adosm1[visits36mo, &quot;id&quot;] # returns all the ids with a visit at 36mo # returns alg and version at 36 months adosm1[visits36mo, c(&quot;ados_algorithm&quot;, &quot;ados_version&quot;)] 3.4 Functions to explore data Out of all the functions to explore a dataframe, I personally find table() duplicated() to be the most useful 3.4.1 Example table() # To get a frequency count of all unique values, # we use the table() # table() takes in 1 or more vectors as input # since every dataframe column could be considered a vector (or list) # we could check for every unique visit with freq counts with table(adosm1$visit) ## ## 18 21 24 30 36 ## 445 5 396 32 146 # we could check for every unique combination of vectors by # providing multiple vector inputs # To see every unique combination of visit and ados algorithm table(adosm1$visit, adosm1$ados_algorithm) ## ## few to no words no words some words ## 18 3 157 93 192 ## 21 0 0 2 3 ## 24 4 65 30 297 ## 30 0 4 0 28 ## 36 6 8 20 112 3.4.2 Checking for duplicates: duplicated() We will first generate a dataframe that has duplicates, to show how to detect duplicates by different subgroups dupDf &lt;- data.frame(id = c(1, 1, 2, 2, 3, 3), visit = c(&#39;10 months&#39;, &#39;20 months&#39;, &#39;10 months&#39;, &#39;10 months&#39;, &#39;20 months&#39;, &#39;20 months&#39;), item1 = c(1, 2, 3, 3, 5, 6)) 3.4.3 duplicated() explained The duplicated function returns a logical vector of the duplicates that exist in a dataframe. The TRUE values represent the index locations of where a duplicate row was found. We could use this logical vector to see where a duplicate exists 3.4.4 duplicated() example duplicateIndices &lt;- duplicated(dupDf) # store dup vector in variable duplicateIndices # view logical vector of duplicates ## [1] FALSE FALSE FALSE TRUE FALSE FALSE dupDf[duplicateIndices, ] ## id visit item1 ## 4 2 10 months 3 3.4.5 Duplicated() by key variables: id and visit we could check for duplicates by columns that should represent a unique combination. in this example: id and visit # to check duplicates by groups dupIndGrouped &lt;- duplicated(dupDf[, c(&quot;id&quot;, &quot;visit&quot;)]) dupDf[dupIndGrouped, ] ## id visit item1 ## 4 2 10 months 3 ## 6 3 20 months 6 3.5 Assignment: adosm2 dataset 3.5.1 Instructions Read in the adosm2.csv file What is the frequency count for every unique visit? What are the ids that exist for the 30 month visit? Are there duplicates by id and visit? What is the frequency count of duplicates vs non-duplicates? 3.6 Additional Resources 3.7 Solution # 1. Read in the adosm2.csv file adosm2Path &lt;- &#39;./datasets/adosm2.csv&#39; adosm2 &lt;- read.csv(adosm2Path, stringsAsFactors = FALSE) # 2. What is the frequency count for every unique visit? table(adosm2$visit) ## ## 24 30 36 sa1 sa2 ## 42 14 469 2 2 # 3, What are the ids that exist for the 30 month visit? adosm2[adosm2$visit == &quot;30&quot;, &quot;id&quot;] ## [1] 20 53 57 71 78 104 222 252 304 306 385 444 451 455 # This works too- adosm2$id[adosm2$visit == &quot;30&quot;] # 4. Are there duplicates by id and visit? any(duplicated(adosm2[, c(&quot;id&quot;, &quot;visit&quot;)])) ## [1] FALSE # 5. What are the frequency count of duplicates vs non-duplicates table(duplicated(adosm2)) ## ## FALSE ## 529 3.8 Basic Stats functions 3.8.1 Mean, Median, Standard Deviation, Summary mean(cars$speed, na.rm = TRUE) ## [1] 15.4 median(cars$dist, na.rm = TRUE) ## [1] 36 sd(cars$speed, na.rm = TRUE) ## [1] 5.287644 summary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 3.9 Linear Regression We will use the mtcars dataset for these examples 3.9.1 Correlation Find correlation between two vars cor.test(mtcars$wt, mtcars$disp) ## ## Pearson&#39;s product-moment correlation ## ## data: mtcars$wt and mtcars$disp ## t = 10.576, df = 30, p-value = 1.222e-11 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.7811586 0.9442902 ## sample estimates: ## cor ## 0.8879799 3.9.2 Creating a Linear Model linearMod &lt;-lm(dist ~ speed, cars) print(linearMod) ## ## Call: ## lm(formula = dist ~ speed, data = cars) ## ## Coefficients: ## (Intercept) speed ## -17.579 3.932 3.9.3 Plotting the Linear Model # create effects object eff &lt;- effects::Effect(&#39;speed&#39;, linearMod) eff ## ## speed effect ## speed ## 4 9.2 14 20 25 ## -1.84946 18.59907 37.47463 61.06908 80.73112 plot(eff) 3.10 Logistic Regression adosm1$ASD_risk &lt;- as.factor(adosm1$recruitment_group == &#39;ASD risk&#39;) adosm1$sarb_f &lt;- as.factor(adosm1$ados_sarb_total) adosm1$gender_factor &lt;- as.factor(adosm1$gender) adosm1$recruitment_group_f &lt;- as.factor(adosm1$recruitment_group) logMod &lt;- glm(ASD_risk ~ sarb_f + gender_factor, adosm1, family = &#39;binomial&#39;) logMod ## ## Call: glm(formula = ASD_risk ~ sarb_f + gender_factor, family = &quot;binomial&quot;, ## data = adosm1) ## ## Coefficients: ## (Intercept) sarb_f1 sarb_f2 ## -0.3815 0.1500 0.2267 ## sarb_f3 sarb_f4 sarb_f5 ## 0.8868 1.1712 1.5137 ## sarb_f6 sarb_f7 sarb_f8 ## 1.5840 0.6224 1.1274 ## sarb_f9 sarb_f10 sarb_f11 ## 2.6826 1.8771 0.7671 ## sarb_f12 sarb_f13 sarb_f14 ## 1.1296 3.2461 2.0244 ## sarb_f15 sarb_f16 sarb_f17 ## 2.0005 1.1525 1.6009 ## sarb_f18 sarb_f19 sarb_f20 ## 1.6125 0.4841 17.1203 ## sarb_f21 sarb_f22 sarb_f23 ## 2.3623 -16.1846 16.9476 ## sarb_f24 sarb_f25 sarb_f26 ## 0.4669 16.9476 17.2042 ## gender_factormale gender_factorMale ## 15.9578 -0.2566 ## ## Degrees of Freedom: 1010 Total (i.e. Null); 982 Residual ## (13 observations deleted due to missingness) ## Null Deviance: 1365 ## Residual Deviance: 1247 AIC: 1305 plot(effects::Effect(c(&#39;sarb_f&#39;, &#39;gender_factor&#39;), logMod)) 3.11 Mixed Effects Models 3.12 Plotting with effects 3.13 Plotting with ggplot 3.14 More Resources 3.15 Bonus Material (Optional) 3.16 String Manipulation What are the most useful use cases for string manipulation? Pattern matching: One can easily automate trudging through a dataset by hand, by finding patterns within the character columns in their dataset Data cleaning, Are their some mispelled or case sensitive datasets? How do we group these cases? 3.16.1 Regular Expressions To find patterns within data that has characters within it, we use regular expressions Regular expressions are expressions that allow one to find patterns. To implement a regular expression in R, we can use the grep function to find patterns, or gsub to both find patterns and substitute patterns with another one. 3.16.1.1 grep grep is a function that we will use to find patterns in a vector of strings the first argument will be the regular expression the second argument will be the vector we are searching within stringVecToSearch &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;bad&#39;, &#39;jab&#39;) regExprPattern &lt;- &#39;a&#39; grep(regExprPattern, stringVecToSearch) # indices of all strings with an &#39;a&#39; ## [1] 1 5 6 # Find patterns that STARTS with a pattern with ^ regExprPattern &lt;- &#39;^b&#39; # in this case, starts with a &#39;b&#39; grep(regExprPattern, stringVecToSearch) ## [1] 2 5 # Find patterns that ENDS with a pattern with $ regExprPattern &lt;- &#39;b$&#39; # in this case, ends with a b grep(regExprPattern, stringVecToSearch) ## [1] 2 6 # If we want to see the values, not the indices of where patterns exist grep(regExprPattern, stringVecToSearch, value=TRUE) ## [1] &quot;b&quot; &quot;jab&quot; 3.16.1.2 Grep Applied to a dataframe # see all columns that STARTS with ados ados_cols &lt;- grep(&#39;^ados&#39;, names(adosm1), value=TRUE) adosm1[, ados_cols] # see all rows that have a an ados algorithm of no words # grep will return row numbers of where a pattern of no words # exists in ados_version no_words_vals &lt;- grep(&#39;no words&#39;, adosm1$ados_version) # use row numbers to filter dataframe adosm1[no_words_vals, ] 3.16.1.3 gsub gsub can be thought of as using grep to find the patterns, but replacing the patterns found with something new. The first argument is the pattern to find The second argument is what to replace with the pattern found The third argument is the vector that holds the pattern to search and replace stringVecToSub &lt;- c(&#39;id&#39;, &#39;visit&#39;, &#39;ad1&#39;, &#39;ad2&#39;, &#39;ad3&#39;, &#39;ad4&#39;) gsub(&#39;ad&#39;, &#39;ados_&#39;, stringVecToSub) ## [1] &quot;id&quot; &quot;visit&quot; &quot;ados_1&quot; &quot;ados_2&quot; &quot;ados_3&quot; &quot;ados_4&quot; 3.16.2 String Concatenation 3.16.2.1 paste 3.16.2.2 paste0 3.16.2.3 sprintf "],
["dataframe-manipulation-extras.html", "Chapter 4 DataFrame Manipulation Extras 4.1 Programming Constructs 4.2 Vectorization 4.3 Write Clean Code", " Chapter 4 DataFrame Manipulation Extras 4.0.1 Rename columns 4.1 Programming Constructs 4.1.1 control statements essentials 4.1.2 if else 4.1.3 for loops 4.2 Vectorization 4.2.1 ifelse() 4.3 Write Clean Code 4.3.1 Max Line Length 4.3.2 Speak through Code 4.3.3 A Comment on Comments "]
]
